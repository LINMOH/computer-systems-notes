# 虚拟内存

## 虚拟内存

    Virtual memory is an abstraction that provides each process with the illusion that it has exclusive use of the main memory.
    
虚拟内存是一种抽象，它让每个进程都以为自己独占了整个内存。每个进程看到的是独立的**虚拟地址空间**（例如 0x0000… 到 0xFFFFFFFF）。实际上，这些地址通过**地址翻译**（硬件 MMU 完成）被映射到真实的物理内存或磁盘上的数据。

虚拟内存依赖操作系统和硬件（CPU and MMU）的协作来实现。每一个进程都有一个虚拟地址空间（Virtual Address Space，VAS），在 32 位系统中是 `0x00000000` ~ `0xFFFFFFFF`，64 位更大。进程中的所有指令都是通过虚拟地址（VA）访问，而不是真实的地址（PA）。

调用内存时，CPU 产生的是虚拟地址，**MMU** 通过**页表**（Page Table）把虚拟内存翻译为物理地址。页表是操作系统为每一个进程维护的，进程 A 的页表把 VA 映射到某些物理内存块，进程 B 的页表则映射到不同的物理内存块。即使两个进程都访问地址 `0x400000`，实际上访问的物理内存的位置是完全不同的，这样就保证了进程之间相互隔离。

**页表基址寄存器**（Page Table Base Register, PTBR）是 CPU 内的一个寄存器，它存放当前进程页表的起始物理位置。当 CPU 执行内存访问时，MMU 会根据 PTBR 的值找到页表，然后查找对应的物理地址。简而言之，PTBR 指向页表。

上下文切换时，操作系统会切换 CPU 使用的 PTBR。这样，切换进程就相当于切换一套地址映射。在进程 A 看来，它有一整片内存；在进程 B 看来，它也有一整片内存。实际上，它们只是操作系统给它们的“不同视角”。

## 进程的虚拟地址空间（Linux 32 位）

<div align="center">
  <img src="../misc/68aae5f058cb8da5c8484ecd.png" alt="image.png">

  Process virtual address space.
</div>

- 可执行文件加载区
    - **只读的代码和数据**：这是内存地址最低的部分，包含进程的机器代码以及字符串字面量这样的只读数据。这部分数据不可修改。
    - **读/写数据**：这部分包含了程序中可修改的全局变量和静态变量。
- 运行时动态分配区
    - **运行时堆**：这部分用于动态内存分配，系统会从这里分配内存给函数，堆是向上增长的（从低地址向高地址），大小在程序运行时会动态变化。
    - **共享库的内存映射区域**：这个区域用于加载共享库，（`.so`、`.dll`），像是 `printf` 这种标准库函数就是从这里加载，这使得多个程序可以共享同一库文件以节省内存（操作系统在加载库时，会把它映射到每个进程的虚拟地址空间）。
    - **用户栈**：这部分存储局部变量、函数参数和返回地址。每当调用一个函数时，一个“栈帧”就会被推入栈中；函数返回时，栈帧被弹出。栈是向下增长的（从高地址向低地址），与堆的增长方向相反。当用户栈和运行时堆的区域重叠时，通常会发生错误栈溢出。
- 系统保留区
    - **内核虚拟内存**：这是内存地址的最高部分，对用户程序是不可见的，这部分保留给系统内核使用，用户无法访问。

虚拟内存的运作需要硬件和操作系统之间精密复杂的交互，具体细节以后会继续深究。

## 参考文献

Bryant, R. E., & O'Hallaron, D. R. (2015). Computer Systems: A Programmer's Perspective (3rd ed.). Pearson.

> 最后修改时间：2025-08-24